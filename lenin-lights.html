<!DOCTYPE html>
<HTML>

<HEAD>

  <title>Dynamic Lighting using Primitive ID - Alexandr Poltavsky, software developer</title>

  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />

  <link rel="stylesheet" type="text/css" href="css/common.css" />
  <link rel="stylesheet" href="highlight/styles/hybrid.css">

</HEAD>

<BODY> 

<div id="wrap">

  <!-- header part -->

  <div id="header">

  <a href="/color-throne.html"><img class="ad" src="images/color-throne-logo-promo.png" title="Color Throne Game"/></a>    

  <a href="/">
      <img class="avatar" width="160" src="images/alexandr-poltavsky-avatar.jpeg" title="Alexandr Poltavsky" align="left"/>
    </a>
    <strong>
      Alexandr Poltavsky <br/> 
      Software developer <br/>
      <em>poltavsky.alexandr&#64;gmail.com</em> 
    </strong>
    <ul id="menu">
      <li><a href="/">Blog Contents</a></li>
      <li><a href="https://github.com/alexpolt/">Github</a></li>
      <li><a href="https://www.shadertoy.com/user/alexpolt">Shadertoy</a></li>
      <li><a href="https://twitter.com/poltavsky_alex">Twitter</a></li>
    </ul>

  </div>


  <div id="content" style="clear: left">

  <!-- here goes the main content -->

  <ul id="main-menu">
    <li id="main-menu-0"><a href="index.html">Programming</a></li>
    <li id="main-menu-1"><a href="index-gfx.html">Graphics</a></li>
    <li id="main-menu-2"><a href="index-off.html">Off-topic</a></li>
  </ul>


<h2>Dynamic Lighting using Primitive ID</h2>

<p>Never thought of using gl_PrimitiveID (SV_PrimitiveID) for anything but recently realized that
  lights can be grouped for a primitive and iterated over in the pixel shader. I decided to cook up
  a WebGL Demo showing this (in WebGL1 I have to supply primitive id in a buffer and use float 
  textures for light parameters). <strong>Warning: for some bizarre reason there are iugly artifacts in 
  Internet Explorer 11</strong>.</p>

<p>The lights are clustered into a 3D array of 25x25x25 depending on the distance from a cell. 
  The total number of lights is 400. During a frame a dynamic float texture is updated: for 
  every face we load the lights from the precomputed array (based on the face's center point) 
  and write them into the texture. In the shader we compute the uv using the primitive id and 
  sample it for each light. </p>

<p>While it sounds quite simple, it actually was problematic to fight popping. It is really hard
  to find the best combination of the number of lights per cluster and the number of lights in
  the shader. Also difficult is to find parameters for the lighting equation so it looks good.</p>

<p>So here is the summary: it is certainly possible to do dynamic lighting using primitive ID but 
  benefits are questionable: too many lights are needed to be provided per face to eliminate 
  popping (in the pixel shader I use a maximum of 32 lights per face). If not for lighting then 
  primitive id can also be used to do the <a href="shader.html">tri info trick</a> without using barycentrics: we can 
  use it to reference into index/vertex buffers and do all the transformations by hand in the 
  shader.</p>

<div class="webgl" webgl_version="1" webgl_div="shader0" init="load_demo">
  <img class="link" src="images/lenin.png" title="Click to show WebGL demo" alt="WebGL demo"/><br/>
  <span>Click to show WebGL demo</span>
</div>

<div class="shader hidden" id="shader0" js="" fn="" style="width: 60%">
  <ul class="close">
    <li title="Info" class="help">?</li>
    <li title="Close Demo" class="close">Close</li>
  </ul>
  <ul class="menu">
    <li title="WebGL Canvas" class="canvas">Canvas</li>
    <li title="Vertex Shader" class="vs">VS</li>
    <li title="Pixel Shader" class="ps">PS</li>
  </ul>
  <canvas hide class="canvas"></canvas>
  <textarea hide class="vs hidden" spellcheck="false">//<!--
attribute vec3 v_in;
attribute vec3 vn_in;
attribute float vid_in;
varying vec3 pos;
varying vec3 vn;
varying float pid;
uniform mat3 cam;
uniform vec3 campos;
uniform float t;
uniform vec2 screen;
uniform float dmax;

void main() {

  vn = cam*vn_in;
  pid = floor( vid_in/3. );
  vec3 p = cam*v_in;
  pos = p/dmax;
  p = p+campos;
  float far = 10000.0;
  float near = 1.0;
  float z = p.z;
  p.x = p.x * screen.y/screen.x;
  p.z = far*(z-near)/(far-near);
  gl_Position = vec4(p,z);
}
//-->
  </textarea>
  <textarea hide class="ps hidden" spellcheck="false">//<!--
precision highp float;
varying vec3 pos;
varying vec3 vn;
varying float pid;

const float pi = 3.14159265;
const float lperface = 32.;

uniform float t;
uniform vec2 ltexsize;
uniform sampler2D ltex;

float round(float v){ return floor(v+.5); }

vec3 getc(float x) {
  vec3 colors[5];
  colors[0]=vec3(200, 60, 25)/255.;
  colors[1]=vec3(70, 40, 90)/255.;
  colors[2]=vec3(80, 110, 90)/255.;
  colors[3]=vec3(120, 90, 40)/255.;
  colors[4]=vec3(150, 50, 70)/255.;

  float v = floor( fract(abs(x)*333.)*5. );
  if(v==0.) return colors[0];
  if(v==1.) return colors[1];
  if(v==2.) return colors[2];
  if(v==3.) return colors[3];
  return colors[4];
}

void main() {
  vec3 norm = normalize(vn);
  vec2 px = 1./ltexsize;
  vec2 uv = vec2( fract(lperface*round(pid)/ltexsize.x)+.5*px.x,
            floor(lperface*round(pid)/ltexsize.x)/ltexsize.y+.5*px.y);
  float kd = 1., n = .0;
  vec3 c = vec3(0,0,0);
  for(float i=.0; i<lperface; i++ ) {
    vec4 l = texture2D( ltex, uv+i*vec2(px.x,0) );
    if( l.w == .0 ) continue;
    n++;
    vec3 ldir = l.xyz-pos;
    float d = clamp(0.,1.,1.-length(ldir));
    kd = abs(dot(normalize(ldir),norm));
    kd = 4.0 * pow(kd, 1.5) * pow(d, 16.);
    vec3 col = getc(l.x);
    c = c+col*kd;
  }
  float gamma = 1./2.2;
  c = pow(c, vec3(gamma) );
  gl_FragColor = vec4(c, 1);
}
//-->
  </textarea>
  <div hide class="help hidden"></div>
  <div class="buttons">
  <button title="Reload Shaders" class="reload">Reload</button>
  <button title="Output WebGL Info in Console" class="log">Log</button>
  <button title="Pause Rendering" class="pause">Pause</button>
  <button title="Go Fullscreen" class="fscreen">FS</button>
  <button title="Rotate/Dont Rotate" id="rot" class="active">Rotate</button>
  </div>
  <div class="clear"></div>
</div>

<p>By the way, have you recognized who's that statue rotating? If not then here is some <a href="lenin.html" title="Vladymir Lenin">info</a>.</p>

<div>

<script src="js/common.js"></script>
<script src="js/loader.js"></script>
<script src="js/math.js"></script>
<script src="js/camera.js"></script>
<script src="js/webgl-quad.js"></script>
<script src="js/webgl.js"></script>


<script>

  var loader_lenin;

  function load_demo (cb) {

    var span = this.querySelector("span");
    var div = this;

    if( !loader_lenin || 
          loader_lenin.failed || 
            !loader_lenin.loaded )

      loader_lenin = load_resources( ["webgl/lenin2dec2.obj"], {} );

    loader_lenin.delay = 500;
    loader_lenin.span_text = "Computing lights, please wait...";
    loader_lenin.span_title = "Please wait";

    var fn = function(){ 
      if( loader_lenin.failed ) 
        alert("Loading " + loader_lenin.failed_src + " failed. Try realoading the page.");
      else if( ! loader_lenin.loaded ) 
        alert("Resources not loaded. Check console output (ctrl+shift+j or F12) and try reloading the page.");
      else {
        loader_lenin.step=2;
        lenin.call ( div, cb );
      }
    };

    load_animation (loader_lenin, span, fn);
  }

  var vb, nb, fcb, idb;
  var d_max=0.0; cells=25, lights_max=400, rotate = true;
  var lights, lradius = 1.0/cells*13;
  var lperface=32, lsort=true;
  var per_frame=5, ltexw, ltexh, ltex;

  function lenin (cb) {


    if( vb === undefined ) {

      load_buffers();
    }

    load_lights.call(this);

    var div = this.getAttribute("webgl_div");
    var canvas = document.querySelector( "div#"+div+" canvas" );

    rotate = true;

    var but_rot = document.getElementById( "rot" );
    but_rot.classList.add("active");
    but_rot.onclick = function() { 
      rotate = this.classList.toggle("active"); this.blur(); 
    };

    var cam = camera_create( { canvas: canvas, nobind: false, personal: false, pos: vec3(0,0,400), speed: 10 } );
    var a=-Math.PI/2048., c=Math.cos(a), s=Math.sin(a);
    var mrot = mat3(vec3(c,0,s),vec3(0,1,0),vec3(-s,0,c));

    compute_lights(cam);

    var opts = {
      bgcolor : [.95, .95, .95, 1],
      buffers : {v_in: vb, vn_in: nb, vid_in: idb},
      draw_size : vb.length/3,
      uniforms : {
        ltexsize: [ltexw,ltexh],
        cam: function(){ return cam.get_m(); }, 
        campos: function(){ return cam.get_pos(); },
        dmax: [d_max],
      },
      textures : { 
        ltex: { tex2d: 1, width: ltexw, height: ltexh, format: "RGBA", type: "FLOAT",
                  minf:"NEAREST", magf:"NEAREST", genmipmap: 0, 
                  data: function(frame,dt) { 
                          if( frame%per_frame == 0 ) return ltex;
                          return null;
                        },
               },
      },
      extensions : [ "OES_texture_float" ],
      onreload : function() { cam.reset_m(); },
      onclose : function() { camera_remove(cam); },
      onpause : function(s) { cam.pause(s); },
      onpresent : function(frame,dt) {
        if( !cam.paused ) {
          if( rotate ) cam.m = mul( cam.m, mrot );
          if(frame%per_frame == 0) compute_lights(cam);
        }
      },
    };
    opts.uniforms.cam.matrix_size = 3;
    cb (opts);
  }

  function load_buffers() {
    var m, v=[], vn=[], f=[];
    var reg = /^v\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)/gm;
    while( (m = reg.exec( loader_lenin.data[0])) !== null )
      v.push( parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]) );

    reg = /^vn\s+([-.\d]+)\s+([-.\d]+)\s+([-.\d]+)/gm;
    while( (m = reg.exec( loader_lenin.data[0])) !== null )
      vn.push( parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]) );

    reg = /^f\s+(\d+)\/\/\d+\s+(\d+)\/\/\d+\s+(\d+)\/\/\d+/gm;
    while( (m = reg.exec( loader_lenin.data[0])) !== null )
      f.push( parseFloat(m[1]), parseFloat(m[2]), parseFloat(m[3]) );

    vb = new Float32Array( f.length*3 );
    nb = new Float32Array( f.length*3 );
    idb = new Float32Array( f.length );
    idb.attrib_size = 1;
    fcb = new Float32Array( f.length );
    var fc = array(9,.0);
    var i;
    for(i=0; i<f.length; i++) {
      var fci = i%3;
      for(var t=0; t<3; t++) {
        fc[fci*3+t] = vb[i*3+t] = v[ (f[i]-1)*3+t ];
        nb[i*3+t] = vn[ (f[i]-1)*3+t ];
      }
      if( i > 0 && fci == 0 ) {
        face_center( i-3, fc );
      }
      idb[i] = i;
    }

    face_center( i-3, fc );

    for(var i=0;i<fcb.length;i++) fcb[i] = fcb[i]/d_max;

    var s = Math.ceil( Math.sqrt( fcb.length/3 ) );
    ltexw = lperface * s;
    ltexh = s;

    ltex = new Float32Array( ltexw * ltexh * 4 );
  }

  function face_center ( f, fc ) {
    for(var i=0; i<3; i++) {
      fcb[f+i] = (fc[i] + fc[i+3] + fc[i+6])/3.;
    }
    d_max = Math.max ( d_max, len([fcb[f],fcb[f+1],fcb[f+2]]) );
  }

  function load_lights() {

    var span = this.querySelector("span");

    lights = array( Math.pow(cells,3), null ).map( function(){ return []; } );

    var v = vec3(), cell_max=0;

    console.info( "computing lights clusters: ", lights.length*lights_max, "loop iterations" );

    span.innerHTML = "Computing lights";

    for(var n=0; n<lights_max; n++) {    

      var lz = Math.random(), 
          ly = Math.random(), 
          lx = Math.random(), 
          lw = 1.;


      for(var z=0.; z<cells; z++)
      for(var y=0.; y<cells; y++)
      for(var x=0.; x<cells; x++) {
        v[0] = lx-x/cells; v[1] = ly-y/cells; v[2] = lz-z/cells;
        var d = len(v);
        if( d > lradius ) continue;
        var l = vec4( lx*2.-1., ly*2.-1., lz*2.-1., lw );
        l.dist_to_cell = d;
        var idx = z*cells*cells+y*cells+x;
        lights[idx].push( l );
        if( lights[idx].length > cell_max ) cell_max = lights[idx].length;
      }

    }

    console.info( "max lights per cell = ", cell_max );

    if( lsort ) {

      console.info( "sorting lights in cells" );
      span.innerHTML = "Sorting lights";

      for(var z=0.; z<cells; z++) {
      for(var y=0.; y<cells; y++) {
      for(var x=0.; x<cells; x++) {
        var idx = z*cells*cells+y*cells+x;
        lights[idx].sort( function(a,b) { return a.dist_to_cell - b.dist_to_cell; } );
      }}}
    }

  }

  function compute_lights(cam) {
    var v = vec3(), logged = 0, lmin=[];
    clear(ltex,.0);
    for(var i=0; i<fcb.length/3; i++) {
      v[0] = fcb[i*3]; v[1] = fcb[i*3+1]; v[2] = fcb[i*3+2];
      v = mul( cam.m, v );
      var x = Math.floor( cells*(.5+.5*v[0]) ), 
          y = Math.floor( cells*(.5+.5*v[1]) ), 
          z = Math.floor( cells*(.5+.5*v[2]) );
      if( x >= cells ) x = cells-1;
      if( y >= cells ) x = cells-1;
      if( x >= cells ) x = cells-1;

      var idx = z*cells*cells+y*cells+x;
      var l = lights[idx];
      var size = Math.min(lperface,l.length);
      for(var n=0; n<size; n++) {
        ltex[i*4*lperface+n*4+0] = l[n][0];
        ltex[i*4*lperface+n*4+1] = l[n][1];
        ltex[i*4*lperface+n*4+2] = l[n][2];
        ltex[i*4*lperface+n*4+3] = l[n][3];
      }
    }
  }

</script>

</div>


<script src="highlight/highlight.pack.js"></script>
<script>
  //hljs.configure({languages: ["C++"]});
  hljs.initHighlightingOnLoad();
</script>


<script>
    /**
     *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
     *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
     */
    /*
    var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    */

    function run_disqus() {  // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        
        s.src = '//alexpolt-github-io.disqus.com/embed.js';
        
        s.setAttribute('data-timestamp', +new Date());

        (d.head || d.body).appendChild(s);

        d.getElementById("disqus_comments").innerHTML = ""; // alexpolt

        return undefined;
    };
</script>
<div id="disqus_comments"><a href="javascript: run_disqus()">read and write commentaries</a></div>
<div id="disqus_thread"></div>
<!--noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments
powered by Disqus.</a></noscript-->



  </div> <!-- end content -->

</div> <!-- end wrap -->



<!-- Google Analytics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-75341409-1', 'auto');
  ga('send', 'pageview');
</script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript">
    (function (d, w, c) {
        (w[c] = w[c] || []).push(function() {
            try {
                w.yaCounter43425229 = new Ya.Metrika({
                    id:43425229,
                    clickmap:true,
                    trackLinks:true,
                    accurateTrackBounce:true
                });
            } catch(e) { }
        });

        var n = d.getElementsByTagName("script")[0],
            s = d.createElement("script"),
            f = function () { n.parentNode.insertBefore(s, n); };
        s.type = "text/javascript";
        s.async = true;
        s.src = "https://mc.yandex.ru/metrika/watch.js";

        if (w.opera == "[object Opera]") {
            d.addEventListener("DOMContentLoaded", f, false);
        } else { f(); }
    })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/43425229" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

</BODY>

